/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const process = require('node:process');
// @ts-ignore -- TS7016: Could not find a declaration file
const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {GoogleAuth} = require('google-auth-library');
const pkgJson = require('./package.json');
const util = require('node:util');
const execFile = util.promisify(require('node:child_process').execFile);
const {setTimeout} = require('timers/promises');
const {readAndVerifyConfig} = require('./config.js');

/** @typedef {import('./config.js').Config} Config */
/** @typedef {import('express').Request} Request */
/** @typedef {import('express').Response} Response */

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;

// 10 min timeout for scanning.
const CLAMD_TIMEOUT = 600000;

// Note: MAX_FILE_SIZE limits the size of files which are sent to th
// ClamAV Daemon.
//
// ClamAV itself has internal limits, which apply both to the total file
// size, and to the size of compressed files inside file containers.
// These are set in the clamd.conf file by bootstrap.sh
//
// Note scanning a 500MiB file can take 5 minutes, so ensure timeout is
// large enough.
const MAX_FILE_SIZE = 500000000; // 500MiB

/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 *
 * @type {Config}
 */
const BUCKET_CONFIG = {
  buckets: [],
  ClamCvdMirrorBucket: '',
};

// Create Clients.
const app = express();
app.use(express.json());
/** @type {any} */
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage({
  userAgent: `cloud-solutions/${pkgJson.name}-usage-v${pkgJson.version}`,
});
const googleAuth = new GoogleAuth();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * For command line testing, use
 *
 * curl -d '{"kind": "storage#object","name":"test_file", "bucket": "BUCKET_NAME" }' -H "Content-Type: application/json" http://localhost:8080
 */
app.post('/', async (req, res) => {
  // Sanity check required values.
  switch (req.body.kind) {
    case 'storage#object':
      await handleGcsObject(req, res);
      break;
    case 'schedule#cvd_update':
      await handleCvdUpdate(req, res);
      break;
    default:
      handleErrorResponse(
        res,
        200,
        `${JSON.stringify(req.body)} is not supported` +
          '(kind must be storage#object or schedule#cvd_update',
      );
      break;
  }
});

/**
 * Handle a POST with a GCS object payload.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleGcsObject(req, res) {
  const file = req.body;
  try {
    if (!file?.name) {
      handleErrorResponse(res, 200, `file name not specified in ${file}`);
      return;
    }
    if (!file?.bucket) {
      handleErrorResponse(res, 200, `bucket name not specified in ${file}`);
      return;
    }
    const fileSize = parseInt(file.size);
    if (fileSize > MAX_FILE_SIZE) {
      handleErrorResponse(
        res,
        200,
        `file gs://${file.bucket}/${file.name} too large for scanning at ${fileSize} bytes`,
        file.bucket,
      );
      return;
    }
    const config = BUCKET_CONFIG.buckets.filter(
      (c) => c.unscanned === file.bucket,
    )[0];
    if (!config) {
      handleErrorResponse(
        res,
        200,
        `Bucket name - ${file.bucket} not in config`,
      );
      return;
    }

    const gcsFile = storage.bucket(file.bucket).file(file.name);
    // File.exists() returns a FileExistsResponse, which is a list with a
    // single value.
    if (!(await gcsFile.exists())[0]) {
      res.json({status: 'deleted'});
      return;
    }

    const clamdVersion = await getClamVersion();
    const startTime = Date.now();
    const readStream = await gcsFile.createReadStream();
    let result;
    try {
      result = await scanner.scanStream(readStream, CLAMD_TIMEOUT);
    } finally {
      // Ensure stream is destroyed in all situations to prevent any
      // resource leaks.
      readStream.destroy();
    }
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      // Move document to the bucket that holds clean documents. This can
      // fail due to permissions or if the file has been deleted.
      await moveProcessedFile(file.name, true, config);

      // Respond to API client.
      res.json({status: 'clean', clam_version: clamdVersion});
    } else {
      // Move document to the bucket that holds infected documents. This can
      // fail due to permissions or if the file has been deleted.
      await moveProcessedFile(file.name, false, config);

      // Respond to API client.
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
    }
  } catch (e) {
    // A 500 will cause Pubsub/EventArc to retry the event.
    let statusCode = 500;

    const errcode = /** @type {import('@google-cloud/storage').ApiError} */ (e)
      .code;
    if (errcode && [403, 404].includes(errcode)) {
      // Permission denied/file not found can be raised by the stream reading
      // and by the object move. They cannot be retried, so respond
      // with success, but log the error.
      statusCode = 200;
    }

    handleErrorResponse(
      res,
      statusCode,
      `gs://${file.bucket}/${file.name}: ${e}`,
      file.bucket,
    );
  }
}

/**
 * Triggers a update check on the CVD Mirror GCS bucket.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleCvdUpdate(req, res) {
  try {
    const result = await execFile('./updateCvdMirror.sh', [
      BUCKET_CONFIG.ClamCvdMirrorBucket,
    ]);
    // look for updated versions in output by looking for
    // "updated (version: " from freshclam output.
    const newVersions = result.stdout
      .split('\n')
      // Look for lines beginning with Downloaded
      .filter((line) => line.indexOf('Downloaded') >= 0);
    for (const version of newVersions) {
      // Do something with version if needed
    }
    res.json({
      status: 'CvdUpdateComplete',
      updated: newVersions.length > 0,
    });
  } catch (err) {
    const e = /** @type {any} */ (err);
    res.status(500).json({message: e.message, status: 'CvdUpdateError'});
  }
}

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res
    .status(200)
    .type('text/plain')
    .send(
      `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}

${pkgJson.description}

`,
    );
});

/**
 * Respond with an error
 *
 * Note: any non-successful status codes will cause the caller (PubSub/Eventarc)
 * to retry sending the event, so use 200 for non-retryable errors.
 *
 * @param {Response} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string?=} unscannedBucket
 */
function handleErrorResponse(
  res,
  statusCode,
  errorMessage,
  unscannedBucket = null,
) {
  res.status(statusCode).json({message: errorMessage, status: 'error'});
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  try {
    const result = await execFile('clamscan', ['--version']);
    return result.stdout.trim();
  } catch (err) {
    return `Error getting ClamAV version: ${err}`;
  }
}

/**
 * Move the file to the relevant bucket.
 *
 * @param {string} fileName name of the file
 * @param {boolean} isClean whether the file is clean
 * @param {Config} config configuration object
 * @return {Promise<void>}
 */
async function moveProcessedFile(fileName, isClean, config) {
  const srcBucket = storage.bucket(config.unscanned);
  const destBucket = storage.bucket(
    isClean ? config.clean : config.infected,
  );

  await srcBucket.file(fileName).move(destBucket.file(fileName));
}

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
