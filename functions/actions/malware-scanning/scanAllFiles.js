import axios from 'axios';
import fs from 'fs';
import os from 'os';
import path from 'path';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';

dayjs.extend(utc);
dayjs.extend(timezone);
export default (firebase) => {

  const SCAN_SERVICE_URL = process.env.SCAN_SERVICE_URL;
  const API_MAX_REQUEST = 100;
  const API_RATE_WINDOW_MS = 60000;
  const UPDATE_LOG_SECOND = 10; // there's a write limit (once per second) to the same object name

  return {
    scanAllFiles,
  };

  /**
   * Scans all files for viruses
   *
   * force - if true then previously scanned files will be rescanned
   * maxFiles - maximum number of files to scan (useful when testing)
   */
  async function scanAllFiles(force = false, maxFiles = 999999) {

    console.log('SCAN_SERVICE_URL', SCAN_SERVICE_URL);

    const started = Date.now();
    let lastUpdate = started;

    // setup the HTTP request to the malware scanner web service

    const options = {
      method: 'POST',
      url: SCAN_SERVICE_URL,
      data: {
        filename: null,
        projectId: process.env.PROJECT_ID,
      },
      headers: {
        'Content-Type': 'application/json',
      },
    };

    // open the storage bucket
    const bucket = firebase.storage().bucket(process.env.STORAGE_URL);

    const processed = [];
    let exception = 'none';

    await createLogFile(bucket, started, processed, exception);

    try {

      // get all files in the bucket
      const [files] = await bucket.getFiles(
        // {
        // prefix: 'exercise/1j25Hmhx4y1M1tF523FH',
        // autoPaginate: false,
        // }
      );

    // scan all files
      let scanResult;
      let countApiCall = 0;
      console.log(files.length + ' Files total');
      for (let i = 0; i < files.length; i++) {

        let file = files[i];

        // there is no point scanning the logs files this function produces
        if (file.name.startsWith('virusScanningLogs')) {
          continue; // skip this file
        }

        if (force || (file.metadata.metadata === undefined || file.metadata.metadata.scanned === undefined)) {

          if (countApiCall >= API_MAX_REQUEST) {
            countApiCall = 0;
            // delay API_RATE_WINDOW_MS milliseconds
            await delayMS(API_RATE_WINDOW_MS);
          }

          // make the HTTP request to scan the file

          options.data.filename = file.name;
          try {
            scanResult = await axios(options);
          } catch (e) {
            console.error(e);
            scanResult = {error: e.message};
          }
          countApiCall++;

          processed.push({
            name: file.name,
            scanned: getScannedDateTime(Date.now()),
            status: scanResult.status || scanResult.error,
          });

        } else { // don't rescan this file

          processed.push({
            name: file.name,
            scanned: getScannedDateTime(file.metadata.metadata.scanned),
            status: file.metadata.metadata.status || null,
          });

        }

        if (processed.length >= maxFiles) {
          break;
        }

        // update the log file every X seconds
        const diffSecond = Math.round((Date.now() - lastUpdate) / 1000);
        if (diffSecond >= UPDATE_LOG_SECOND) {
          await createLogFile(bucket, started, processed, exception);
          lastUpdate = Date.now();
        }

      }
    } catch (e) {
      exception = e;
    }

    await createLogFile(bucket, started, processed, exception, true);
  }

  /**
   * Delay for n milliseconds
   * @param {number} n
   */
   function delayMS(n) {
    return new Promise(resolve => setTimeout(resolve, n));
  }

  /**
   * Converts the 'scanned' metadata into a human-readable datetime format
   * @param {null|string} meta
   * @returns null|string
   */
  function getScannedDateTime(meta) {
    let date;
    let time;
    if (meta) {
      const scanned = new Date(parseInt(meta));
      date = scanned.toJSON().slice(0, 10).split('-').reverse().join('/');
      time = scanned.toLocaleTimeString('en-GB', { timeZone: 'Europe/London' });
      return date + ' ' + time;
    }
    return null;
  }

  /**
   * Creates a log file for the specified files that have been processed
   *
   * @param {bucket} bucket - the bucket that was scanned
   * @param {Date} started - the date/time the scanning started
   * @param {array} processed - the files that were processed (to log)
   * @param {string|object} exception - the exception during scanning files (to log)
   * @param {boolean} finished - if false, 'In Progress...' will be written to the log
   */
  async function createLogFile(bucket, started, processed, exception = 'none', finished = false) {

    const content = `
Virus Scanning Log

Scan service url: ${SCAN_SERVICE_URL}
Start time: ${getScannedDateTime(started)}
End time: ${getScannedDateTime(Date.now())}

Processed (total: ${processed.length}):

${finished ? '' : '*** Scanning in progress ***'}

${JSON.stringify(processed, null, 2)}


Exception:

${JSON.stringify(exception, null, 2)}
    `;

    // save log to local temp file
    const isoDatetime = dayjs(started).tz('Europe/London').format('YYYY-MM-DDTHH:mm:ss.SSS');
    const fileName = isoDatetime + '.json';
    const tempFilePath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tempFilePath, content);

    // upload log file to storage
    await bucket.upload(tempFilePath, {
      destination: 'virusScanningLogs/' + fileName,
    });

    // delete local temp file
    fs.unlinkSync(tempFilePath);

    // pause 1 second after updating the log file because this function is called multiple times
    // and we are only allowed to update the log file max. 1 time per second
    // ref: https://cloud.google.com/storage/docs/concepts-techniques#object-updates
    await delayMS(1000);

  }

};
