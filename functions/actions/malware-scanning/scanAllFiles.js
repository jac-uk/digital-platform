const request = require('request-promise');
const fs = require('fs');
const os = require('os');
const path = require('path');

module.exports = (config, firebase) => {

  const SCAN_SERVICE_URL = config.SCAN_SERVICE_URL;
  const API_MAX_REQUEST = 100;
  const API_RATE_WINDOW_MS = 60000;
  const UPDATE_LOG_SECOND = 10; // there's a write limit (once per second) to the same object name

  return {
    scanAllFiles,
  };

  /**
   * Scans all files for viruses
   *
   * force - if true then previously scanned files will be rescanned
   * maxFiles - maximum number of files to scan (useful when testing)
   */
  async function scanAllFiles(force = false, maxFiles = 999999) {

    const started = Date.now();
    let lastUpdate = started;

    // setup the HTTP request to the malware scanner web service
    const options = {
      method: 'POST',
      uri: SCAN_SERVICE_URL,
      body: {
        filename: null,
        projectId: config.PROJECT_ID,
      },
      json: true,
    };

    // open the storage bucket
    const bucket = firebase.storage().bucket(config.STORAGE_URL);

    const processed = [];
    let exception = 'none';

    await createLogFile(bucket, started, processed, exception);

    try {
      // get all files in the bucket
      const [files] = await bucket.getFiles();

      // scan all files
      let scanResult;
      let countApiCall = 0;
      for (let i = 0; i < files.length; i++) {
        let file = files[i];

        // there is no point scanning the logs files this function produces
        if (file.name.startsWith('virusScanningLogs')) {
          continue; // skip this file
        }

        if (force || file.metadata.metadata.scanned === undefined) {

          if (countApiCall >= API_MAX_REQUEST) {
            countApiCall = 0;
            // delay API_RATE_WINDOW_MS milliseconds
            await delayMS(API_RATE_WINDOW_MS);
          }

          // make the HTTP request to scan the file
          options.body.filename = file.name;
          try {
            scanResult = await request(options);
          } catch (e) {
            scanResult = { error: e.message };
          }
          countApiCall++;

          // If the file is clean, download the file content
          if (scanResult.status === 'clean') {
            const [fileContent] = await file.download();

            // Calculate checksum using the file content
            const checksum = createChecksum(fileContent);

            // Store the checksum in Firestore
            await addChecksumToFirestore(firebase.firestore(), file.name, path.basename(file.name), checksum);
          }

          processed.push({
            name: file.name,
            scanned: getScannedDateTime(Date.now()),
            status: scanResult.status || scanResult.error,
          });

        } else { // don't rescan this file

          processed.push({
            name: file.name,
            scanned: getScannedDateTime(file.metadata.metadata.scanned),
            status: file.metadata.metadata.status || null,
          });

        }

        if (processed.length >= maxFiles) {
          break;
        }

        // update the log file every X seconds
        const diffSecond = Math.round((Date.now() - lastUpdate) / 1000);
        if (diffSecond >= UPDATE_LOG_SECOND) {
          await createLogFile(bucket, started, processed, exception);
          lastUpdate = Date.now();
        }

      }
    } catch (e) {
      exception = e;
    }

    await createLogFile(bucket, started, processed, exception, true);
  }

  /**
   * Delay for n milliseconds
   * @param {number} n
   */
  function delayMS(n) {
    return new Promise(resolve => setTimeout(resolve, n));
  }

  /**
   * Converts the 'scanned' metadata into a human-readable datetime format
   * @param {null|string} meta
   * @returns null|string
   */
  function getScannedDateTime(meta) {
    if (meta) {
      const scanned = new Date(parseInt(meta));
      date = scanned.toJSON().slice(0, 10).split('-').reverse().join('/');
      time = scanned.toLocaleTimeString('en-GB', { timeZone: 'Europe/London' });
      return date + ' ' + time;
    }
    return null;
  }

  /**
   * Creates a log file for the specified files that have been processed
   *
   * @param {bucket} bucket - the bucket that was scanned
   * @param {Date} started - the date/time the scanning started
   * @param {array} processed - the files that were processed (to log)
   * @param {string|object} exception - the exception during scanning files (to log)
   * @param {boolean} finished - if false, 'In Progress...' will be written to the log
   */
  async function createLogFile(bucket, started, processed, exception = 'none', finished = false) {

    const content = `
Virus Scanning Log

Scan service url: ${SCAN_SERVICE_URL}
Start time: ${getScannedDateTime(started)}
End time: ${getScannedDateTime(Date.now())}

Processed (total: ${processed.length}):

${finished ? '' : '*** Scanning in progress ***'}

${JSON.stringify(processed, null, 2)}


Exception:

${JSON.stringify(exception, null, 2)}
    `;

    // save log to local temp file
    const isoDatetime = new Date(new Date(started).toLocaleString('en-GB', { timeZone: 'Europe/London' })).toISOString();
    const fileName = isoDatetime + '.json';
    const tempFilePath = path.join(os.tmpdir(), fileName);
    fs.writeFileSync(tempFilePath, content);

    // upload log file to storage
    await bucket.upload(tempFilePath, {
      destination: 'virusScanningLogs/' + fileName,
    });

    // delete local temp file
    fs.unlinkSync(tempFilePath);

    // pause 1 second after updating the log file because this function is called multiple times
    // and we are only allowed to update the log file max. 1 time per second
    // ref: https://cloud.google.com/storage/docs/concepts-techniques#object-updates
    await delayMS(1000);
    const checksumsCollection = firestore.collection('checksums');
    const existingDoc = await checksumsCollection.where('filename', '==', fileName).get();

    if (!existingDoc.empty) {
      existingDoc.forEach(async doc => {
        if (doc.data().checksum !== checksum) {
          await doc.ref.update({ checksum, created_at: new Date() });
        }
      });
    } else {
      await checksumsCollection.add({
        filepath: filePath,
        filename: fileName,
        checksum,
        created_at: new Date(),
      });
    }
  }

};
